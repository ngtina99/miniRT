1. check in libft and miniRT makfile CFLAGS (I comment out on my own PC, because it is not compatible)
2. make sure to submit ALL libraries including minilibx
3. OPENGLFLAGS are only 1 time in makefile
4. rename my_mlx_pixel_put to for example set_pixel_color

5. I don't understand why the 0.0f set up to {0.0f, 0.0f, -1.0f}; - Tina
Yulia: this was to make it return something if it's (0,0,0) vector (which is not really a vector), not to devide by 0 in the next steps.
I chose this value as "default view", as if user is standing and looking right at the screen (-z axis)

t_vec3d	normalize(t_vec3d v)
{
	float magnitude;

	magnitude = sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
	if (magnitude == 0.0f) //TODO
		return (t_vec3d){0.0f, 0.0f, -1.0f};
	v.x /= magnitude;
	v.y /= magnitude;
	v.z /= magnitude;
	return (v);
}

6. I don't understand this part - Tina
    // Calculate the right and up vectors for the camera's orientation
	t_vec3d world_up = {0.0f, 1.0f, 0.0f};
	t_vec3d right = normalize(cross_product(forward, world_up));
	t_vec3d up = normalize(cross_product(right, forward));

Yulia: world_up - this is our Y axis (not relative, just one on the screen), we need that as a reference, to not loose screen orientation :) 
right, up, forward - this is like camera coordinate system. based on it's orientation, we calculate it's own X, Y and Z.
right = X_for_camera
up = Y_for_camera
forward = Z_for_camera
we need that to build real view from camera point.

7. 	t_vec3d closest_hit_point; // TODO is it needed later?
we are using it in find_closest_object to write value that we got. I think we will need later, if not - can remove. 

9.     else if (projection_length >= cylinder.height) {
        //return normalize(cylinder.axis); // Normal points outward for top cap
		return normalize(scale_vector(cylinder.axis, 1)); //TODO I think we have to change to this but test later
    }